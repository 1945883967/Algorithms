# 第1章 基础
和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。
## 1.1 基础编程模型

* 程序是对算法精确、优雅和完全的描述；
* 可以通过运行程序来学习算法的各种性质；
* 可以在应用程序中直接使用这些算法。
* 
  相比用自然语言描述算法，这些是重要而巨大的优势。
  我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模型**。
### 1.1.1 Java程序的基本结构
一段**Java 程序（类）**或者是一个**静态方法（函数）库**，或者定义了一个**数据类型**。要创建静态方法库和定义数据类型，会用到下面五种语法，它们是Java语言的基础，也是大多数现代语言所共有的。

* 原始数据类型：它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
* 语句：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：声明、赋值、条件、循环、调用和返回。
* 数组：数组是多个同种数据类型的值的集合。
* 静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
* 字符串：字符串是一连串的字符，Java 内置了对它们的一些操作。
* 标准输入 / 输出：标准输入输出是程序与外界联系的桥梁。
* 数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程

  在例子中，BinarySearch 类有两个静态方法 rank()和 main()。第一个方法 rank()含有四条语句：两条声明语句，一条循环语句（该语句中又有一条赋值语句和两条条件语句）和一条返回语句。

  第二个方法 main()包含三条语句：一条声明语句、一条调用语句和一个循环语句（该语句中又包含一条赋值语句和一条条件语句）。要执行一个 Java 程序，首先需要用 javac命令编译它，然后再用 java命令运行它。例如，要运行 BinarySearch，首先要输入 javac BinarySearch.java（这将生成一个叫 BinarySearch.class的文件，其中含有这个程序的 Java 字节码）；然后再输入 java BinarySearch（接着是一个白名单文件名）把控制权移交给这段字节码程序。
  ![94594a8062589d40b0cd252f3e05e8cc.png](en-resource://database/7089:0)
  ![5a7a444020966920bc7a6f11e859e389.png](en-resource://database/7091:0)
### 1.1.2 原始数据类型与表达式
**数据类型**是一组数据和对其所能进行操作的集合。
以下是四种基本数据类型
* 整型，及其算术运算符（int）；
* 浮点型，及其算术运算符（double）；
* 布尔型，它的值 {true, false}及其逻辑操作（boolean）；
* 字符型，它的值是你能够输入的英文字母数字字符和符号（char）。

Java 程序控制的是用**标识符**命名的变量。每个变量都有自己的类型并存储了一个合法的值。

**Java程序的基本组成**
| 术语         | 例子                      | 定义                                                         |
| ------------ | ------------------------- | ------------------------------------------------------------ |
| 原始数据类型 | int double boolean char   | 一组数据和对其所能进行的操作的集合（Java语言内置）           |
| 标识符       | a abc Ab$ a_b ab123 lo hi | 由子母、数字、下划线和$组成的字符串，首字符不能是数字        |
| 变量         | [任意标识符]              | 表示某种类型的值                                             |
| 运算符       | + - *  /                  | 表示某种数据类型的运算                                       |
| 字面量       | int 1 0 -42               | 值在源代码中表示                                             |
| 表达式       | int lo+(hi-lo)/2          | 字面量、变量或是能够计算出结果的一串字面量、变量和运算符的组合 |
只要能够指定**值域**和在此值域上的操作，就能定义一个**数据类型**。

int和 double是我们熟悉的算数运算；而 boolean则是逻辑运算。需要注意的重要一点是，+、-、 \*、/都是被重载过的——根据上下文，同样的运算符对不同类型会执行不同的操作。级运算的关键性质是运算产生的数据的数据类型和参与运算的数据的数据类型是相同的。因此我们经常要做近似处理，很多情况下由表达式定义的准确值并非参与表达式运算的值。例如，5/3的值是 1而 5.0/3.0的值是 1.66666666666667，两者都很接近但并不准确地等于 5/3。

![46bfe911fb1d90f1b485be40de1bd68e.png](en-resource://database/7095:0)
![93999936185a987ae4eaa3986496e199.png](en-resource://database/7099:0)
#### 1.1.2.1 表达式
Java使用的是中缀表达式：一个字面量（或是一个表达式），紧接着是一个运算符，再接着是另一个字面量（或者另一个表达式）。当一个表达式包含一个以上的运算符时，运算符的作用顺序非常重要，因此 Java 语言规范约定了如下的运算符优先级：运算符 \*和 /（以及 %）的优先级高于 +和 -（优先级越高，越早运算）；**在逻辑运算符中，!拥有最高优先级，之后是 &&，接下来是 ||** 。 一般来说，相同优先级的运算符的运算顺序是从左至右。与在正常的算数表达式中一样，使用括号能够改变这些规则。因为不同语言中的优先级规则会有些许不同，我们在代码中会使用括号并用各种方法努力消除对优先级规则的依赖。
#### 1.1.2.2 类型转换
**如果不会馈送信息，数据会自动提升为高级的数据类型**。例如，在表达式 1+2.5中，1 会被转换为浮点数 1.0，表达式的值也为 double值 3.5。**转换**指的是在表达式中把**类型名放在括号里**将其后的值转换为括号中的类型。例如，(int)3.7的值是 3而 (double)3的值是 3.0。需要注意的是将浮点型转换为整型将会**截断小数部分而非四舍五入**，在复杂的表达式中的类型转换可能会很复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。
#### 1.1.2.3 比较
下列运算符能够比较相同数据类型的两个值并产生一个布尔值：相等（==）、不等（!=）、小于（<）、小于等于（<=）、大于（>）和大于等于（>=）。这些运算符被称为**混合类型**运算符，因为它们的结果是布尔型，而不是参与比较的数据类型。结果是布尔型的表达式被称为**布尔表达式**。这种表达式是**条件语句**和**循环语句**的重要组成部分。
#### 1.1.2.4 其他原始数据类型
Java 的整型能够表示 2<sup>32</sup> 个不同的值，用一个 32 位二进制即可表示。

与此相似，double型的标准规定为 64 位。这些大小对于一般应用程序中使用的整数和实数已经足够了。为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：
* 64 位整数，及其算术运算符 (long)；
* 16 位整数，及其算术运算符 (short)；
* 16 位字符，及其算术运算符 (char)；
* 8 位整数，及其算术运算符 (byte)；
* 32 位单精度实数，及其算术运算符 (float)。
#### 1.1.3 语句
Java 程序是由语句组成的。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。

* 声明语句：创建某种类型的变量并用标识符为其命名。
* 赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。Java 还有一些隐式赋值的语法可以使某个变量的值相对于当前值发生变化，例如将一个整型值加 1。
* 条件语句：能够简单地改变执行流程——根据指定的条件执行两个代码段之一。
* 循环语句：更彻底地改变执行流程——只要条件为真就不断地反复执行代码段中的语句。
* 调用和返回语句：和静态方法有关，是改变执行流程和代码组织的另一种方式。

程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。一般来说代码的结构都是嵌套的。
#### 1.1.3.1 声明语句
声明语句将一个变量名和一个类型在编译时关联起来。Java 需要我们用声明语句指定变量的名称和类型。这样，我们就清楚地指明了能够对其进行的操作。Java 是一种强类型的语言，因为 Java编译器会检查类型的一致性（例如，它不会允许将布尔类型和浮点类型的变量相乘）。变量可以声明在第一次使用之前的任何地方——一般我们都在首次使用该变量的时候声明它。变量的作用域就是定义它的地方，一般由相同代码段中声明之后的所有语句组成。
#### 1.1.3.2 赋值语句
赋值语句将（由一个表达式定义的）某个数据类型的值和一个变量关联起来。在 Java 中，当我们写下 c=a+b时，我们表达的不是数学等式，而是一个操作，即令变量 c的值等于变量 a的值与变量 b的值之和。当然，在赋值语句执行后，从数学上来说 c的值必然会等于 a+b，但语句的目的是改变 c的值（如果需要的话）。赋值语句的左侧必须是单个变量，右侧可以是能够得到相应类型的值的任意表达式。
#### 1.1.3.3 条件语句
大多数运算都需要用不同的操作来处理不同的输入。在 Java 中表达这种差异的一种方法是 if语句：
if (<boolean expression>)
｛<block statements> }
else                         
｛<block statements> }
如果<boolean expression>为true，则执行if下面的代码块，当为false时执行else下的代码块。
#### 1.1.3.4 循环语句
许多运算都需要重复。Java语言中处理这种计算的基本语句是格式是：

* while(<boolean expression>) {<block statements>}

while语句和 if语句的形式相似（只是用 while代替了 if），但意义大有不同。当布尔表达式的值为假（false）时，代码什么也不做；当布尔表达式的值为真（true）时，执行代码段（和 if一样），然后再次检查布尔表达式的值，如果仍然为真，再次执行代码段。如此这般，只要布尔表达式的值为真，就继续执行代码段。我们将循环语句中的代码段称为**循环体**。
#### 1.1.3.5 break与continue语句
* break语句，立即从循环中退出
* continue语句，立即开始下一轮循环。
### 1.1.4 简便记法
程序有很多种写法，我们追求清晰、优雅和高效的代码。这样的代码经常会使用以下这些广为流传的简便写法（不仅仅是 Java，许多语言都支持它们）。
#### 1.1.4.1 声明并初始化
可以将声明语句和赋值语句结合起来，在声明（创建）一个变量的同时将它初始化。例如， int i = 1;创建了名为 i的变量并赋予其初始值 1。最好在接近首次使用变量的地方声明它并将其初始化（为了限制它的作用域）。
#### 1.1.4.2 隐式赋值
当希望一个变量的值相对于其当前值变化时，可以使用一些简便的写法。
* 递增/递减运算符,++i;等价于i=i+1;且表达式为i+1。类似的，--i；等价于i=i-1;。i++；和i--;的意思分别与上述的++i;和--i;相同，只是表达式的值为 i的值。
* 其他复合运算符，在赋值语句中将一个二元运算符写在等号之前，等价于将左边的变量放在等号右边并作为第一个操作数。例如，i/=2;等价于 i=i/2;。注意，i += 1;等价于 i = i + 1;（以及 ++i;）。
#### 1.1.4.3 单语句代码段
如果条件或循环语句的代码段只有一条语句，代码段的花括号可以省略。
#### 1.1.4.4 for语句
很多循环的模式都是这样的：初始化一个索引变量，然后使用 while循环并将包含索引变量的表达式作为循环的条件，while循环的最后一条语句会将索引变量加 1。使用 Java 的 for语句可以更紧凑地表达这种循环：
for (<initialize>; <boolean expression>; <increment>){
​    <block statements>
}
除了几种特殊情况之外，这段代码都等价于：
<initialize>;
while (<boolean expression>){
​    <block statements> 
​    <increment>;
}

我们将使用 for语句来表示对这种初始化—递增循环用法的支持。

**各种Java语句及其示例**
![221d12008b4b823a23da2230cfac1937.png](en-resource://database/7101:0)

### 1.1.5 数组
数组能够顺序存储相同类型的多个数据。除了存储数据，我们也希望能够访问数据。访问数组中的某个元素的方法是**将其编号然后索引**。如果我们有 N 个值，它们的编号则为 0 至 N-1。这样对于 0 到 N-1 之间任意的 i，我们就能够在 Java 代码中**用 a[i]唯一地表示第 i+1个元素**的值。在 Java中这种数组被称为一维数组。
#### 1.1.5.1 创建并初始化数组
在Java中创建一个数组需要三步：
* 声明数字的类型和名字
* 创建数组
* 初始化数组

声明数组时，需要指定数组的名称和它含有的数据的类型。在创建数组时，需要指定数组的长度（元素的个数）。
例如，在以下代码中，“完整模式”部分创建了一个有 N个元素的 double数组，所有的元素的初始值都是 0.0。第一条语句是数组的声明，它和声明一个相应类型的原始数据类型变量十分相似，只有类型名之后的方括号说明我们声明的是一个数组。第二条语句中的关键字 new使 Java创建了这个数组。我们需要在运行时明确地创建数组的原因是 Java 编译器在编译时无法知道应该为数组预留多少空间（对于原始类型则可以）。for语句初始化了数组的 N个元素，将它们的值置为 0.0。在代码中使用数组时，一定要依次声明、创建并初始化数组。忽略了其中的任何一步都是很常见的编程错误。

```java
	//完整模式
		double[] a;
		a = new double[5];
		for (int i = 0; i < a.length; i++) {
			a[i]=0.0;
		}
	//简化模式
		double[] a1 = new double[5];
	//声明初始化
		int[] a2 = {1,2,3,4,5,6,7};

```

#### 1.1.5.2 简化写法
为了精简代码，我们通常会使用Java对数组默认的初始化来将三个步骤和为一条语句，即上面的简化写法。等号左边声明了数组，等号右边创建了数组。这种方式，对数组采用默认的初始化值来初始化数组。
double 默认初始值0.0，int默认初始值0，boolean默认初始值为false，char默认初始值为0；
#### 1.1.5.3 使用数组
在声明并创建数组之后，在代码的任何地方都能通过数组名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是固定的。程序能够通过
a.length获取数组 a[]的长度，而它的最后一个元素总是 a[a.length – 1]。Java 会自动进行边界检查——如果你创建了一个大小为 N的数组，但使用了一个小于 0或者大于 N-1的索引访问它，程序会因为运行时抛出 ArrayOutOfBoundsException异常而终止。

```java
	// 找出数组中最大的元素
	public int max(int[] a) {
		int max=a[0];
		for (int i = 1; i < a.length; i++)
			if(a[0]<a[i]) max=a[i];
		return max;
	}
	
	//计算数组元素的平均值
	public double average(double[] a) {
		int n = a.length;
		double sum = 0.0;
		for (int i = 0; i < n; i++) 
			sum+=a[i];
		return sum/n;
	}
	
	//复制数组
	public int[] copy(int[] a) {
		int n = a.length;
		int[] b = new int[n];
		for(int i = 0; i < n; i++) 
			b[i] = a[i];
		return b;
	}
	
	//颠倒数组的顺序
	public static void reversal(int[] a) {
		int n = a.length;
		for (int i = 0; i < n/2; i++) {
			int temp = a[i];
			a[i] = a[n-1-i];
			a[n-1-i] = temp;
		}
	}
	
	//矩阵相乘（方阵） a[][]*b[][]=c[][]
	public int[][] multiply(int[][] a,int[][]b){
		int n = a.length;
		int[][] c = new int[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j <n; j++) {
				//计算行i和列j的点乘
				c[i][j] = a[i][j] * b[i][j];
			}
		}
		return c;
	}
```

#### 1.1.5.4 其别名
请注意，数组名表示的是整个数组——如果我们将一个数组变量赋予另一个变量，那么两个变量将会指向同一个数组。例如以下这段代码：
```java
int[] a = new int[N];
...
a[i] = 1234;
...
int[] b = a;
...
b[i] = 5678;  // a[i] 的值也会变成 5678
```
这种情况叫做起别名，有时可能会导致难以察觉的问题。如果你是想将数组复制一份，那么应该声明、创建并初始化一个新的数组，然后将原数组中的元素值**挨个复制到新数组**。
```java
import java.util.Arrays;
public class T2 {
       public static void main(String[] args) {
             int[] a = {1,2,3,4,5};
             int[] b = new int[5];
             b=a;
             System.out.println(Arrays.toString(b));
             for (int i = 0; i < b.length; i++) {
                    b[i]=0;
             }
             System.out.println(Arrays.toString(a));
       }
}/**Out
[1, 2, 3, 4, 5]
[0, 0, 0, 0, 0]
*/
```

#### 1.1.5.5 二维数组
在 Java 中二维数组就是一维数组的数组。二维数组可以是参差不齐的（元素数组的长度可以不一致），但大多数情况下（根据合适的参数 M 和 N）我们都会使用 M×N，即 M 行长度为 N 的数组的二维数组（也可以称数组含有 N 列）。在 Java 中访问二维数组也很简单。二维数组 a\[][]的
第 i行第 j列的元素可以写作 a\[i][j]。声明二维数组需要两对方括号。创建二维数组时要在类型名之后分别在方括号中指定行数以及列数，例如：
```
double[][] a = new double[M][N];
```
我们将这样的数组称为 M×N 的数组。我们约定，第一维是行数，第二维是列数。和一维数组一样， Java 会将数值类型的数组元素初始化为 0，将布尔型的数组元素初始化为 false。默认的初始化对二维数组更有用，因为可以节约更多的代码。下面这段代码和刚才只用一行就完成创建和初始化的语句是等价的：
```
ouble[][] a;
a = new double[M][N];
for (int i = 0; i < M; i++)
    for (int j = 0; j < N; j++)
         a[i][j] = 0.0;
```
在将二维数组初始化为 0 时这段代码是多余的，但是如果想要初始化为其他值，我们就需要嵌套的 for循环了。

### 1.1.6 静态方法
在Java静态方法对于每个类只有一份内存地址，不管这个类有几个实例对象，它们都共享一份内存，与普通方法不同。静态方法可以由类名直接调用。
#### 1.1.6.1 静态方法
方法封装了由一系列语句所描述的运算。方法需要参数（某种数据类型的值）并根据参数计算出某种数据类型的返回值（例 public static double sqrt ( double c )如数学函数的结果）或者产生某种副作用（例如打印一个值）。每一个静态方法都由**签名**（关键字public static 以及函数的的返回值，方法名以及一串各种类型的参数）和**函数体**（即包含在花括号中的代码）组成的。

**经典静态方法实现**

```java
	//计算一个整数的绝对值
	public static int abs(int a) {
		if(a<0)
			return -a;
		else 
			return a;
	}
	
	//计算一个浮点数的绝对值
	public static double abs(double a) {
		if(a<0)
			return -a;
		else 
			return a;
	}
	
	//判断一个数是否为素数（质数）(定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。)
	public static boolean isPrime(int n) {
		if(n<2) return false;
		for (int i = 0; i*i < n; i++) {
			if(n%i==0) return false;
		}
		return true;
	}
	
	//计算平方根（牛顿迭代法）
	public static double sqrt(double a) {
		if(a<0) return Double.NaN;//Nan 一个常数，持有double类型的非数字（NaN）值。 它相当于返回的值Double.longBitsToDouble(0x7ff8000000000000L) 。
		double err = 1e-15;
		double t = a;
		while(Math.abs(t-a/t)>err*t)
			t = (a/t+t)/2.0;
		return t;
	}
	
	//计算直角三角形的斜边
	public static double hypotenuse(double a,double b) {
		return Math.sqrt(a*a+b*b);
	}
	
	//计算调和级数
	public static double H(int n) {
		double sum = 0.0;
		for (int i = 0; i <= n; i++) {
			sum += 1.0/i;
		}
		return sum;
	}
```

#### 1.1.6.2 静态方法的调用
调用静态方法的方法是写出方法名并在后面的括号中列出参数值（在同一类中调用，这里讲的是算法，不考虑面向对象），用逗号分隔。当调用是表达式的一部分时，方法的返回值将会替代表达式中的方法调用。例如， BinarySearch 的 main()函数中对系统方法 Arrays.sort()的调用产生的副作用，是将数组中的所有条目有序地排列。调用方法时，它的参数变量将被初始化为调用时所给出的相应表达式的值。返回语句将结束静态方法并将控制权交还给调用者。如果静态方法的目的是计算某个值，返回语句应该指定这个值（如果这样的静态方法在执行完所有的语句之后都没有返回语句，编译器会报错）。
#### 1.1.6.3 方法的性质
* 方法的参数按值传递：在方法中参数变量的使用方法和局部变量相同，唯一不同的是参数变量的初始值是由调用方提供的。
* 方法名可以被重载：例如，Java 的 Math 包使用这种方法为所有的原始数值类型实现了Math.abs()、Math.min()和 Math.max()函数。重载的另一种常见用法是为函数定义两个版本，其中一个需要一个参数而另一个则为该参数提供一个默认值。
* 方法只能返回一个值，但可以包含多个返回语句：一个 Java 方法只能返回一个值，它的类型是方法签名中声明的类型。静态方法第一次执行到一条返回语句时控制权将会回到调用代码中。尽管可能存在多条返回语句，任何静态方法每次都只会返回一个值，即被执行的第一条返回语句的参数。
* 方法可以产生副作用：方法的返回值可以是 void，这表示该方法没有返回值。返回值为void的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回给调用方。我们称 void类型的静态方法会产生副作用（接受输入、产生输出、修改数组或者改变系统状态）。例如，我们的程序中的静态方法 main()的返回值就是 void，因为它的作用是向外输出。
#### 1.1.6.4 递归
**方法可以调用自己**，例如，下面给出了 BinarySearch的 rank()方法的另一种实现。我们会经常使用递归，因为递归代码比相应的非递归代码更加简洁优雅、易懂。我们可以用数学归纳法证明这段注释所解释的算法的正确性。
编写递归代码时要注意以下三点：
* 递归总有一个**最简单的情况**----方法的第一句总是一个包含return的条件语句语句。

* 递归调用总是尝试去解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。

* 递归调用的父问题和尝试解决的子问题之间不应该有交集。

  ```java
  //二分查找递归版本
  public class E04BinarySearchRecursion {
  	
  	public static int rank(int key, int[] a) {
  		return rank(key,a,0,a.length-1);
  	}
  	public static int rank(int key, int[] a,int lo,int hi) {
  		//如果key存在与a[]中，他的索引不会小于lo,且不会大于hi
  		if( lo > hi) return -1;
  		int mid = lo +(lo+hi)/2;
  		if(key < a[mid]) return rank(key, a,lo,mid-1);
  		else if(key > a[mid]) return rank(key, a, mid+1, hi);
  		return mid;
  	}
  }
  ```

  违背其中任意一条都可能得到错误的结果或是低效的代码（见练习 1.1.19 和练习 1.1.27），而坚持这些原则能写出清晰、正确且容易评估性能的程序。使用递归的另一个原因是我们可以使用数学模型的来估计程序的性能。

  #### 1.1.6.5 基础编程模型
  **静态方法库**是定义在一个 Java 类中的一组静态方法。类的声明是 public class加上类名，以及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是 .java。
  #### 1.1.6.6 模块化编程
  这个模型的最重要之处在于通过静态方法库实现了模块化编程。我们可以构造许多个静态方法
  库（模块），一个库中的静态方法也能够调用另一个库中定义的静态方法。这能够带来许多好处：

  * 	程序整体的代码量很大时，每次处理的模块大小仍然适中；
  * 	可以共享和重用代码而无需重新实现；
  * 	很容易用改进的实现替换老的实现；
  * 	可以为解决编程问题建立合适的抽象模型；
  * 	缩小调试范围（请见 1.1.6.7 节关于单元测试的讨论）

### 1.1.8 字符串
字符串是由一组字符（char类型的值）组成的，一个String类型的字面量包括一对双引号和其他字符。比如“Hello world”。
#### 1.1.8.1 字符串的拼接
和各种原始数据类型一样，Java 内置了一个串联 String类型字符串的运算符（+）。拼接两个 String类型的字符串将得到一个新的 String值，其中第一个字符串在前，第二个字符串在后。
例子：
```
String s = "hello" + " world";
```
#### 1.1.8.2 类型转换
字符串的两个主要用途分别是将用户从键盘输入的内容转换成相应数据类型的值以及将各种数据类型的值转化成能够在屏幕上显示的内容。Java 的 String类型为这些操作内置了相应的方法，而且 Integer 和 Double 库还包含了分别和 String类型相互转化的静态方法。
![1553391004298](C:\Users\minghai\AppData\Roaming\Typora\typora-user-images\1553391004298.png)

#### 1.1.8.3 自动转换
我们很少明确使用刚才提到的 toString()方法，因为 Java 在连接字符串的时候会自动将任意数据类型的值转换为字符串：如果加号（+）的一个参数是字符串，那么 Java 会自动将其他参数都转换为字符串（如果它们不是的话）。除了像 "The square root of 2.0 is " + Math. sqrt(2.0)这样的使用方式之外，这种机制也使我们能够通过一个**空字符串 ""将任意数据类型的值转换为字符串值**。
#### 1.1.8.4 命令行参数
在 Java 中字符串的一个重要的用途就是使程序能够接收到从命令行传递来的信息。这种机制很简单。当你输入命令 java和一个库名以及一系列字符串之后，Java 系统会调用库的 main()方法并将那一系列字符串变成一个数组作为参数传递给它。

### 1.1.10 二分查找
```
public class E03BinarySearch {
       public static int rank(int key, int[] a) {
             int lo = 0;
             int hi = a.length-1;
             while(lo<=hi) {
                    int mid = lo + (lo+hi)/2;
                    if(key < a[mid]) hi = mid;
                    else if(key > a[mid]) lo = mid;
                    else return mid;
             }
             return -1;
       }
}
```
#### 1.1.10.1 二分查找
算法是由静态方法rank()实现的，它接受一个整数键和一个已经有序的 int数组作为参数。如果该键存在于数组中则返回它的索引，否则返回 -1。算法使用两个变量 lo和 hi，并保证如果键在数组中则它一定在a[lo..hi]中，然后方法进入一个循环，不断将数组的中间键（索引为 mid）和被查找的键比较。如果被查找的键等于 a[mid]，返回 mid；否则算法就将查找范围缩小一半，如果被查找的键小于a[mid]就继续在左半边查找，如果被查找的键大于 a[mid]就继续在右半边查找。算法找到被查找的键或是查找范围为空时该过程结束。二分查找之所以快是因为它只需检查很少几个条目（相对于数组的大小）就能够找到目标元素（或者确认目标元素不存在）。



