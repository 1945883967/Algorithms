# 第1章 基础-1.4算法分析
科学方法的一条关键原则是我们所设计的实现必须是可重现的，他人也可以验证假设的真实性。所有的假设也必须是**可证伪**的，这样我们才能确定某个假设是错的（并需要改正）。

程序在不同的计算机上的运行时间之比通常是一个常数。

一个程序运行的时间主要和两点有关：
*  **执行每条语句的耗时** 取决于计算机、Java编译器和操作系统
*  **执行每条语句的频率** 取决于程序本身和输入。

许多程序的运行时间只取决于其中的一部分指令。

对于绝大多数程序，得到其运行时间的数学模型所需的步骤如下：
* 确定输入模型，定义问题规模
* 识别内循环
* 根据内循环中的操作确定成本模型
* 对于给定的输入，判断这些操作的执行频率

### 内存
Java对内存的使用使用是经过精心设计的：**程序的每个值在每次运行时所需的内存量都是一样的**

Java的重要特性之一就是它的**内存分配系统**。

分析程序运行时所需的内存时，重点看程序中的**声明语句**。且在分析中我们会将复杂的对象简化为原始数据类型（原始数据类型的内存是事先定义好的，且容易理解）。
计算所需内存时：只需将**变量的数量**和**它们所对应的字节数**分别相乘并**汇总**即可。

对内存使用的分析和硬件以及Java的不同实现中的各种差异有关，因此这里的例子不是一成不变的，但可以用来参考学习在条件允许的情况下如何分析内存的使用。
例如：许多数据结果都涉及对机器地址的表示，而在各种计算机中一个机器地址所需的内存又各不相同。现在广泛使用的64位架构中典型的表示机器地址方式是8个字节，许多老式的32位架构只使用4个字节表示机器地址，这里以8个字节为例：
**原始数据类型的常见内存、需求**
| 类型    | 字节 |
| ------- | ---- |
| boolean | 1    |
| byte    | 1    |
| char    | 2    |
| int     | 4    |
| float   | 4    |
| long    | 8    |
| double  | 8    |

**对象**
一个对象所使用的内存量是：**所有实例变量**使用的内存量与**对象本身的开销（一般是16字节）**相加，这些开销包括对象的类的引用、垃圾回收集信息以及同步信息。
另外，一般内存的使用都会填充为8字节（64位计算机中的机器字）的倍数。

例如：一个Integer对象会使用24字节（16字节的对象开销，4字节保存它的int值以及4个填充字节）。

对象的引用一般是内存地址，因此会使用8字节。例如Counter对象：

```java
publci class Counter{
    private String name;
    private int count;
}
```
一个Counter对象需要32个字节：
* 16个字节的对象开销
* 8个字节用与它的String型实例变量（一个引用）
* 4个字节用与int变量
* 4个填充字节

当我们说一个对象引用占内存时，我们会单独说明它所指向的对象所占的内存，因此这个内存（Counter)使用量并没有包含String值所使用的内存。

非静态内部类也属于引用开销。
（书中有详细的对内存开销图的描述 p127）

java中数组被实现为对象，它们一般都会因为记录长度而需要额外的内存。

一个原始数据类型的数组一般需要24字节的头信息（16字节的对象开销，4字节用于保存长度，4填充字节）在加上保存值所需的内存。
例如：一个含有N个int值的数组需要占用（24+4N）个字节（会被填充为8的倍数），一个含有N个double值的数组需要使用（24+8N）字节。

一个**对象数组**就是一个对象的引用的数组，所以我们应该在对象所需的内存之外加上引用所需的内存。例如：一个含有N个Date对象的数组
```java
public  class Date{
    private  final int month;
    private  final int day;
    private final int yeat;
    ··············································
}
```
需要使用24字节（数组开销）加上8N字节（所有引用）加上每个对象的32个字节（每个Date占16个对象本身开销，三个int占3\*4一共12个字节，所以共占32个字节，16+12=28占内存为8的倍数），总共（24+40N）个字节。

二维数组是一个数组的数组（每一个数组都是一个对象）。例如：一个MxN的double类型的二维数组需要使用24个字节（数组的数组的开销）加上8M个字节（所有元素数组的引用）加上24M字节（所有元素数组的开销）加上8MN字节（M个长度为N的double类型的数组），总共（8MN+32+24) ~ 8MN字节。当数组元素时对象时计算方法类似。结果相同，用来指向数组的引用的数组以及所有的这些对象本身。

**字符串对象**
String的标准实现含有4个实例变量：一个指向字符数组的引用（8字节）和三个int值（各4个字节）。第一个int描述的是**字符数组中的偏移量**，第二个int值是一个**计数器**（**字符数组的长度**），第三个int值是一个散列值。每个String有40个字节（16字节表示对象，三个int实例变量各需四个字节，加上数组的引用8个字节和4个填充字节）。

String的char数组常常是多个字符串**共享的**（**偏移量和计数器保证了这种机制**）。因为String对象是不可变的，这种设计使String的实现在能够在多个对象都含有相同的char[]数组时节省内存。

一个长度为N的String对象一般需要使用40字节（String对象本身）加上（24+2N）字节（字节数组），总共（64+2N)字节。

Java中字符串的表示尽可能的避免了复制字符串中的符，当调用substring()方法时，就创建了一个新的String对象（40字节），它任然使用相同的char数组，因此该字符串的子字符串只会使用40字节的内存。含有原始的字符数组的别名存在于字符串中，字符串对象的偏移量和长度域标记了子字符串的位置，换句话说，一个字符串所需的额外的内存时一个常数，构造一个字符串所需的时间也是常数。

在编程领域中最常见的错误或许就是：
* 过于关注程序的性能
* 完全忽略程序的性能

**不成熟的优化是所有的罪恶之源**

**成本模型** **内循环代码**